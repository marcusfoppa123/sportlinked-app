// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

const supabaseUrl = "https://tanfwjpaukclrgiugafk.supabase.co";
const supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRhbmZ3anBhdWtjbHJnaXVnYWZrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ3Mjg1MzcsImV4cCI6MjA2MDMwNDUzN30.xxlUor0cSLAWiYee1B54P57SVUT6GFoGiRO7tHHgmsk";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  }
});

// Add helper function for checking follow status
export const checkIfUserIsFollowing = async (currentUserId: string, targetUserId: string): Promise<boolean> => {
  if (!currentUserId || !targetUserId) return false;
  
  try {
    const { data, error } = await supabase
      .from('followers')
      .select('id')
      .eq('follower_id', currentUserId)
      .eq('following_id', targetUserId)
      .maybeSingle();
    
    if (error) {
      console.error('Error checking follow status:', error);
      return false;
    }
    
    return !!data;
  } catch (err) {
    console.error('Exception checking follow status:', err);
    return false;
  }
};

// Add helper function for following a user
export const followUser = async (currentUserId: string, targetUserId: string): Promise<{ success: boolean, error?: any }> => {
  if (!currentUserId || !targetUserId) {
    return { success: false, error: 'Invalid user IDs' };
  }
  
  try {
    // First check if already following to prevent duplicate entries
    const isFollowing = await checkIfUserIsFollowing(currentUserId, targetUserId);
    if (isFollowing) {
      return { success: true }; // Already following, consider it a success
    }
    
    const { data, error } = await supabase
      .from('followers')
      .insert({
        follower_id: currentUserId,
        following_id: targetUserId
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error following user:', error);
      return { success: false, error };
    }
    
    return { success: true };
  } catch (err) {
    console.error('Exception following user:', err);
    return { success: false, error: err };
  }
};

// Add helper function for unfollowing a user
export const unfollowUser = async (currentUserId: string, targetUserId: string): Promise<{ success: boolean, error?: any }> => {
  if (!currentUserId || !targetUserId) {
    return { success: false, error: 'Invalid user IDs' };
  }
  
  try {
    const { error } = await supabase
      .from('followers')
      .delete()
      .eq('follower_id', currentUserId)
      .eq('following_id', targetUserId);
    
    if (error) {
      console.error('Error unfollowing user:', error);
      return { success: false, error };
    }
    
    return { success: true };
  } catch (err) {
    console.error('Exception unfollowing user:', err);
    return { success: false, error: err };
  }
};

// Check if two users follow each other
export const checkMutualFollow = async (userA: string, userB: string) => {
  const [aFollowsB, bFollowsA] = await Promise.all([
    checkIfUserIsFollowing(userA, userB),
    checkIfUserIsFollowing(userB, userA)
  ]);
  return aFollowsB && bFollowsA;
};

// Create conversation if not exists (user1_id < user2_id for uniqueness)
export const createConversationIfNotExists = async (userA: string, userB: string) => {
  const [user1, user2] = [userA, userB].sort();
  const { data, error } = await supabase
    .from('conversations')
    .select('*')
    .or(`user1_id.eq.${user1},user2_id.eq.${user2}`)
    .maybeSingle();
  if (!data) {
    await supabase.from('conversations').insert({
      user1_id: user1,
      user2_id: user2
    });
  }
};

// Fetch all conversations for a user
export const getUserConversations = async (userId: string) => {
  return supabase
    .from('conversations')
    .select('*')
    .or(`user1_id.eq.${userId},user2_id.eq.${userId}`)
    .order('created_at', { ascending: false });
};

// Fetch all messages for a conversation
export const getConversationMessages = async (conversationId: string) => {
  return supabase
    .from('messages')
    .select('*')
    .eq('conversation_id', conversationId)
    .order('created_at', { ascending: true });
};

// Send a message
export const sendMessage = async (conversationId: string, senderId: string, text: string) => {
  return supabase.from('messages').insert({
    conversation_id: conversationId,
    sender_id: senderId,
    text,
    created_at: new Date().toISOString()
  });
};

export const searchProfilesAndHashtags = async (query: string) => {
  // Search profiles
  const { data: profiles, error: profilesError } = await supabase
    .from('profiles')
    .select('id, full_name, username, avatar_url, role')
    .or(`full_name.ilike.%${query}%,username.ilike.%${query}%`)
    .limit(5);

  // Search posts for hashtags in the hashtags array column
  const { data: posts, error: postsError } = await supabase
    .from('posts')
    .select('id, hashtags')
    .contains('hashtags', query ? [query] : [])
    .limit(10);

  if (profilesError || postsError) {
    console.error('Search error:', profilesError || postsError);
    return { profiles: [], hashtags: [] };
  }

  // Extract unique hashtags from posts
  const hashtags = Array.from(new Set(
    posts
      ?.map(post => post.hashtags || [])
      .flat()
      .filter(tag => tag.toLowerCase().includes(query.toLowerCase()))
  ));

  return {
    profiles: profiles || [],
    hashtags: hashtags
  };
};

export const getPostsByHashtag = async (hashtag: string) => {
  const lowerHashtag = hashtag.toLowerCase();
  const { data: posts, error } = await supabase
    .from('posts')
    .select(`
      *,
      profiles:user_id (
        id,
        full_name,
        username,
        avatar_url,
        role
      ),
      likes:likes(count),
      comments:comments(count)
    `)
    .contains('hashtags', [lowerHashtag])
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching hashtag posts:', error);
    return [];
  }

  return posts.map(post => ({
    ...post,
    user: post.profiles,
    stats: {
      likes: Array.isArray(post.likes) && post.likes[0] && typeof post.likes[0].count === 'number' ? post.likes[0].count : 0,
      comments: Array.isArray(post.comments) && post.comments[0] && typeof post.comments[0].count === 'number' ? post.comments[0].count : 0
    }
  }));
};
